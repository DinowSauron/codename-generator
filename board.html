<!doctype html>
<html lang="pt-BR">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tabuleiro Gerado</title>
  <link rel="icon" href="./icons/favicon.svg" type="image/svg+xml">
  <style>
    :root {
      --pad: 14px;
      --bg: #f6f7fb;
      --cell-size: calc((100vw - 60px) / 8);
      /* will be clamped later by js */
      --vazio-dark-overlay: rgba(0, 0, 0, 0.42);
      --hidden-opacity: 0.28;
      --vazio-hidden-opacity: 0.22;
      --vazio-escuro-opacity: 0.08;
      --transition-fast: 150ms;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      padding: 16px;
      background: var(--bg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto;
      -webkit-font-smoothing: antialiased;
      color: #111;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    h1 {
      font-size: 18px;
      margin: 0;
    }

    .controls {
      display: flex;
      gap: 10px;
      width: 100%;
    }

    button {
      flex: 1;
      padding: 12px;
      font-size: 17px;
      border-radius: 12px;
      border: 0;
      cursor: pointer;
    }

    button.primary {
      background: #0077ff;
      color: #fff;
      box-shadow: 0 6px 14px rgba(0, 119, 255, 0.18);
    }

    button.ghost {
      background: #fff;
      border: 1px solid #ddd;
    }

    main {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .frame {
      padding: 10px;
      border-radius: 14px;
      display: inline-block;
      margin-top: 8px;
      box-shadow: 0 8px 26px rgba(20, 20, 30, 0.08);
      background: #fff;
    }

    .grid {
      display: grid;
      gap: 8px;
      background: transparent;
      border-radius: 10px;
      padding: 8px;
      background-clip: padding-box;
    }

    .square {
      aspect-ratio: 1 / 1;
      width: 48px;
      border-radius: 10px;
      background: #eee;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: white;
      user-select: none;
      cursor: pointer;
      transition: transform var(--transition-fast) ease, box-shadow var(--transition-fast) ease, opacity 180ms ease, filter 180ms ease;
      position: relative;
      will-change: transform, opacity;
      box-shadow: 0 2px 6px rgba(15, 15, 20, 0.04), inset 0 -1px 0 rgba(255, 255, 255, 0.02);
      overflow: hidden;
    }

    .square.hidden {
      opacity: var(--hidden-opacity);
      filter: brightness(0.65);
      box-shadow: none;
    }

    .square.vazio.hidden {
      opacity: var(--vazio-hidden-opacity);
      filter: brightness(0.5);
    }

    /* Estado quando uma célula vazia (não colorida) é clicada: escurecer mais */
    .square.vazio.vazio-escuro {
      /* manter a opacidade do elemento para que o overlay seja totalmente visível */
      opacity: .2;
      /* força um brilho bem baixo para escurecer o conteúdo */
      filter: brightness(0.18);
      /* inset shadow overlay to darken the visible cell area (mais opaco) */
      box-shadow: inset 0 0 0 9999px rgba(0, 0, 0, 0.56);
      transition: box-shadow var(--transition-fast) ease, transform var(--transition-fast) ease, filter 180ms ease;
    }

    .info {
      margin-top: 12px;
      font-size: 14px;
      color: #444;
    }

    @media (max-width:420px) {
      .square {
        width: 44px;
        border-radius: 8px;
      }

      button {
        padding: 12px;
        font-size: 16px;
      }
    }

    /* Dark mode overrides */
    body.dark {
      background: #07101a;
      color: #e6eef8
    }

    body.dark .frame,
    body.dark .card {
      background: #0b1622;
      color: #e6eef8
    }

    body.dark .square {
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.35);
    }

    body.dark .square.vazio {
      background: #1a2430
    }

    body.dark .info {
      color: #c8d9ee
    }

    /* Share modal theming (uses CSS variables so dark mode can override) */
    :root {
      --modal-bg: var(--bg);
      --qr-bg: #fff;
      --sharebox-bg: rgba(0, 0, 0, 0.04);
      --share-icon-filter: none;
    }

    body.dark {
      --modal-bg: #0b1622;
      --qr-bg: #07101a;
      --sharebox-bg: rgba(255, 255, 255, 0.04);
      --share-icon-filter: invert(1) brightness(1.2);
    }

    /* Modal-specific selectors */
    #shareModal #modalDialog {
      background: var(--modal-bg);
      color: inherit;
    }

    #shareModal #qrContainer {
      background: var(--qr-bg);
    }

    #shareModal #shareUrlBox {
      background: var(--sharebox-bg);
    }

    /* sharing icon adapts to dark mode */
    img.share-icon {
      transition: filter 150ms ease, opacity 150ms ease;
      filter: var(--share-icon-filter);
    }

    body.dark .controls button.ghost {
      background: #0b1622;
      color: #e6eef8;
      border-color: #233447
    }
  </style>
</head>

<body>
  <header>
    <div>
      <h1>Tabuleiro</h1>
      <div style="font-size:13px;color:#666" id="configSummary"></div>
    </div>
    <div class="controls" style="max-width:460px;">
      <button id="regenerate" class="primary">Gerar novamente</button>
      <button id="back" class="ghost">Voltar</button>
      <button id="shareBtn" class="ghost" title="Compartilhar tabuleiro"
        style="margin-left:6px;padding:8px 10px;font-size:13px;border-radius:10px;flex:0 0 auto;min-width:92px">
        <img class="share-icon" src="./icons/sharing.svg" alt="Compartilhar"
          style="width:18px;height:18px;vertical-align:middle;">
      </button>
    </div>
  </header>

  <main>
    <div id="frame" class="frame">
      <div id="grid" class="grid"></div>
    </div>

    <div class="info" id="infoText"></div>
  </main>

  <!-- Share modal -->
  <div id="shareModal" aria-hidden="true" style="display:none">
    <div id="modalBackdrop"
      style="position:fixed;inset:0;background:rgba(0,0,0,0.45);backdrop-filter:blur(2px);z-index:1200;display:flex;align-items:center;justify-content:center;padding:20px">
      <div id="modalDialog" role="dialog" aria-modal="true"
        style="background:var(--modal-bg);border-radius:12px;padding:18px;max-width:360px;width:100%;box-shadow:0 12px 40px rgba(10,10,20,0.4);text-align:center;color:inherit">
        <button id="modalClose" aria-label="Fechar"
          style="position:absolute;right:18px;top:18px;border:0;background:transparent;font-size:18px;cursor:pointer;color:inherit">✕</button>
        <div style="margin-top:4px;margin-bottom:8px;font-weight:600">Compartilhar tabuleiro</div>
        <div id="qrContainer"
          style="width:260px;height:260px;margin:8px auto;border-radius:10px;overflow:hidden;display:flex;align-items:center;justify-content:center;background:var(--qr-bg);padding:8px">
          <!-- QR image will be inserted here -->
          <img id="qrImage" alt="QR code" style="max-width:100%;height:auto;display:block;border-radius:6px">
        </div>
        <div id="shareUrlBox"
          style="max-width:260px;margin:8px auto;overflow:hidden;border-radius:10px;background:var(--sharebox-bg);padding:8px">
          <a id="shareUrlText" href="#" target="_blank" rel="noopener"
            style="display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:inherit;text-decoration:none">link</a>
        </div>
        <div style="margin-top:10px;display:flex;gap:8px;justify-content:center">
          <button id="copyLinkBtn" class="primary" style="padding:8px 12px;border-radius:8px">Copiar link</button>
          <button id="closeBtn" class="ghost" style="padding:8px 12px;border-radius:8px">Fechar</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Recupera config
    const raw = localStorage.getItem('tabuleiroConfig');
    if (!raw) {
      alert('Configuração não encontrada. Voltando para a página de configuração.');
      window.location.href = '/';
    }
    let cfg = JSON.parse(raw);

    // lê parâmetro de share (se vier via URL ?share=<base64>) e aplica como estado compartilhado
    function getQueryParam(name) {
      const url = window.location.search.substring(1);
      const params = new URLSearchParams(url);
      return params.get(name);
    }

    function b64DecodeUnicode(str) {
      // decode base64 handling unicode
      try {
        return decodeURIComponent(Array.prototype.map.call(atob(str), function (c) {
          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
      } catch (e) { return null }
    }

    const sharedParam = getQueryParam('share');
    let sharedState = null;
    if (sharedParam) {
      try {
        const txt = b64DecodeUnicode(sharedParam);
        if (txt) sharedState = JSON.parse(txt);
        // if shared contains cfg, override local cfg for rendering
        if (sharedState && sharedState.cfg) { cfg = sharedState.cfg; }
      } catch (e) { sharedState = null; }
    }
    const gridEl = document.getElementById('grid');
    const frameEl = document.getElementById('frame');
    const configSummary = document.getElementById('configSummary');
    const infoText = document.getElementById('infoText');
    const regenerateBtn = document.getElementById('regenerate');
    const backBtn = document.getElementById('back');
    const shareBtn = document.getElementById('shareBtn');

    // initial summary; will be updated by makeGrid() to include seed
    configSummary.textContent = `${cfg.largura} x ${cfg.altura} — Itens: ${cfg.itens}, Exclusões: ${cfg.exclusoes}`;

    (function () {
      try {
        const saved = localStorage.getItem('siteTheme');
        if (saved === 'dark') document.body.classList.add('dark');
      } catch (e) { }
    })();

    // small fast hash to convert a string into a 32-bit number (xfnv1a)
    function xfnv1a(str) {
      let h = 2166136261 >>> 0;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619) >>> 0;
      }
      return h >>> 0;
    }

    // mulberry32 PRNG - deterministic from a 32-bit seed
    function mulberry32(a) {
      return function () {
        a |= 0;
        a = (a + 0x6D2B79F5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function makeRngFromSeed(seed) {
      // seed may be a number or string
      const s = (typeof seed === 'number') ? seed : xfnv1a(String(seed));
      return mulberry32(s);
    }

    // Fisher-Yates shuffle but using a provided rng function
    function shuffle(arr, rng = Math.random) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function makeGrid(seedOverride) {
      const width = cfg.largura;
      const height = cfg.altura;
      const totalCells = width * height;
      gridEl.innerHTML = '';

      // Decide cor inicial aleatória usando RNG derivado da seed
      // determine seed to use: preference order -> seedOverride, cfg.seed, generate new
      let seedToUse = seedOverride || cfg.seed;
      if (!seedToUse) {
        // gerar seed aleatória curta (hex) usando crypto quando disponível
        try {
          const arr = new Uint32Array(1);
          window.crypto.getRandomValues(arr);
          seedToUse = arr[0].toString(16);
        } catch (e) {
          seedToUse = String(Math.floor(Math.random() * 0xFFFFFFFF));
        }
        // persistir seed no cfg para permitir reprodução (não sobrescreve sharedState explicitamente)
        cfg.seed = seedToUse;
        try { localStorage.setItem('tabuleiroConfig', JSON.stringify(cfg)); } catch (e) { }
      }

      // build RNG
      const rng = makeRngFromSeed(seedToUse);

      // show seed in summary
      configSummary.textContent = `${cfg.largura} x ${cfg.altura} — Itens: ${cfg.itens}, Exclusões: ${cfg.exclusoes} — Seed: ${seedToUse}`;

      const colors = { blue: '#2b6df6', red: '#e23e3e', gray: '#eee', black: '#111' };
      const startIsBlue = rng() < 0.5;
      const startColorName = startIsBlue ? 'blue' : 'red';
      const startColor = startIsBlue ? colors.blue : colors.red;
      const otherColor = startIsBlue ? colors.red : colors.blue;

      // Aplica "borda" ao redor do tabuleiro (frame)
      frameEl.style.background = startColor;
      frameEl.style.padding = '10px'; // já definido; cria borda com cor
      // grid contém uma pequena área branca por dentro => simula borda colorida
      gridEl.style.background = '#fff';
      gridEl.style.borderRadius = '10px';
      gridEl.style.padding = '8px';

      // Ajusta tamanho das colunas conforme largura/viewport
      // calcula tamanho máximo que caiba no viewport (mobile-friendly)
      const maxWidth = Math.min(window.innerWidth - 40, 680); // padding
      const cellGap = 8;
      const size = Math.floor((maxWidth - (width - 1) * cellGap - 16) / width);
      const cellSize = Math.max(36, Math.min(72, size)); // clamp
      // define grid template
      gridEl.style.gridTemplateColumns = `repeat(${width}, ${cellSize}px)`;

      // preenche células
      const cells = [];
      for (let i = 0; i < totalCells; i++) {
        const d = document.createElement('div');
        d.className = 'square';
        d.style.width = cellSize + 'px';
        d.style.borderRadius = Math.max(6, cellSize * 0.12) + 'px';
        d.style.background = '#eee';
        d.dataset.index = i;

        // Adiciona evento de clique para ocultar/mostrar
        // - Células coloridas continuam alternando a classe 'hidden'
        // - Células vazias (não coloridas) alternam a classe 'vazio-escuro' para escurecer mais
        d.addEventListener('click', function () {
          if (this.classList.contains('vazio')) {
            this.classList.toggle('vazio-escuro');
            // remove 'hidden' se presente para evitar estados conflitantes
            this.classList.remove('hidden');
          } else {
            this.classList.toggle('hidden');
            // garantir que não reste a classe de vazio escuro
            this.classList.remove('vazio-escuro');
          }
        });

        gridEl.appendChild(d);
        cells.push(d);
      }

      // se veio um estado compartilhado via URL, renderizamos exatamente esse estado
      if (sharedState && Array.isArray(sharedState.cells) && sharedState.cells.length === totalCells) {
        // usar frame color se fornecido
        if (sharedState.frameColor) frameEl.style.background = sharedState.frameColor;

        sharedState.cells.forEach((cState, i) => {
          const el = cells[i];
          if (!el) return;
          // cor: cState.color é string como 'blue'|'red'|'black'|'gray' OR hex
          if (cState.color === 'gray' || cState.color === 'grey' || !cState.color) {
            el.style.background = colors.gray;
            el.dataset.color = 'gray';
            el.classList.add('vazio');
          } else if (cState.color === 'black') {
            el.style.background = colors.black;
            el.dataset.color = 'black';
          } else if (cState.color === 'red') {
            el.style.background = colors.red;
            el.dataset.color = 'red';
          } else if (cState.color === 'blue') {
            el.style.background = colors.blue;
            el.dataset.color = 'blue';
          } else if (/^#/i.test(cState.color)) {
            el.style.background = cState.color;
            el.dataset.color = cState.color;
          }

          if (cState.hidden) el.classList.add('hidden');
          if (cState.vazioEscuro) el.classList.add('vazio-escuro');
        });
      } else {
        // cálculo de distribuição de cores entre itens
        const itens = cfg.itens;
        const exclusoes = cfg.exclusoes;
        // startColor recebe vantagem em ímpar
        const startCount = Math.ceil(itens / 2);
        const otherCount = Math.floor(itens / 2);

        // índices disponíveis
        let indices = Array.from({ length: totalCells }, (_, i) => i);
        shuffle(indices, rng);

        // pega posições para cor inicial
        const startIndices = indices.splice(0, startCount);
        // pega posições para outra cor
        const otherIndices = indices.splice(0, otherCount);

        // pinta as cores
        startIndices.forEach(i => {
          cells[i].style.background = startColor;
          cells[i].dataset.color = startColorName;
        });
        otherIndices.forEach(i => {
          cells[i].style.background = otherColor;
          cells[i].dataset.color = startIsBlue ? 'red' : 'blue';
        });

        // agora pega exclusões a partir dos índices restantes (que não foram coloridos)
        // indices array ainda contém os remanescentes (por causa dos splice acima)
        if (exclusoes > 0) {
          // garantia: itens + exclusoes <= totalCells por validação anterior
          const exclIndices = indices.splice(0, exclusoes);
          exclIndices.forEach(i => {
            cells[i].style.background = colors.black;
            cells[i].dataset.color = 'black';
          });
        }

        // As células restantes (se houver) ficam cinza e são marcadas como vazias
        indices.forEach(i => {
          cells[i].style.background = colors.gray;
          cells[i].dataset.color = 'gray';
          cells[i].classList.add('vazio');
        });
      }

      // Inserir ícones centrais para células coloridas
      const iconMap = { blue: 'circle.svg', red: 'cross.svg', black: 'triangle.svg' };
      cells.forEach((c) => {
        const col = c.dataset.color;
        // apenas para cores com ícone mapeado (não para 'gray')
        if (iconMap[col]) {
          // evite duplicar ícones em re-renders
          if (!c.querySelector('img')) {
            const img = document.createElement('img');
            img.src = `./icons/${iconMap[col]}`;
            img.alt = col + ' icon';
            img.style.width = '52%';
            img.style.height = '52%';
            img.style.objectFit = 'contain';
            img.style.pointerEvents = 'none';
            c.appendChild(img);
          }
        } else {
          // remover possível img em células vazias
          const existing = c.querySelector('img');
          if (existing) existing.remove();
        }
      });

      // info textual
      if (sharedState) {
        infoText.innerHTML = `Estado compartilhado — Itens: ${cfg.itens}, Exclusões: ${cfg.exclusoes}.<br><small>Clique nos quadrados para ocultar/mostrar</small>`;
      } else {
        infoText.innerHTML = `
      Cor inicial: <strong style="color:${startColor};">${startColorName.toUpperCase()}</strong>.
      Itens: ${itens} ( ${startColorName}=${startCount}, ${startIsBlue ? 'red' : 'blue'}=${otherCount} ).
      Exclusões (pretos): ${exclusoes}.
      <br><small>Clique nos quadrados para ocultar/mostrar</small>
    `;
      }

      // Para acessibilidade: torna as células táteis com border small shadow
      cells.forEach(c => {
        c.style.boxShadow = 'inset 0 -2px 0 rgba(0,0,0,0.04)';
      });
    }

    // Botões
    regenerateBtn.addEventListener('click', () => {
      // gera nova seed aleatória e renderiza com ela
      let newSeed;
      try {
        const arr = new Uint32Array(1);
        window.crypto.getRandomValues(arr);
        newSeed = arr[0].toString(16);
      } catch (e) {
        newSeed = String(Math.floor(Math.random() * 0xFFFFFFFF));
      }
      cfg.seed = newSeed;
      try { localStorage.setItem('tabuleiroConfig', JSON.stringify(cfg)); } catch (e) { }
      makeGrid(newSeed);
    });

    // Serializa o estado atual do tabuleiro e gera um link shareable (base64)
    function b64EncodeUnicode(str) {
      return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p1) {
        return String.fromCharCode('0x' + p1);
      }));
    }

    function collectBoardState() {
      // Para compartilhamento leve: compartilhar apenas a configuração (incluindo seed)
      // Dessa forma, o receptor reconstroi o tabuleiro a partir de largura/altura/itens/exclusoes/seed
      // em vez de transportar o estado explícito de cada célula.
      return {
        cfg: cfg
      };
    }

    async function shareBoard() {
      try {
        const payload = collectBoardState();
        const txt = JSON.stringify(payload);
        const b64 = b64EncodeUnicode(txt);
        const shareUrl = `${location.origin}${location.pathname}?share=${b64}`;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(shareUrl);
          alert('Link copiado para a área de transferência!');
        } else {
          prompt('Copie este link:', shareUrl);
        }
      } catch (e) {
        alert('Erro ao gerar link de compartilhamento.');
      }
    }

    if (shareBtn) {
      shareBtn.addEventListener('click', async () => {
        // build share URL then show modal with QR + link
        try {
          const payload = collectBoardState();
          const txt = JSON.stringify(payload);
          const b64 = b64EncodeUnicode(txt);
          const shareUrl = `${location.origin}${location.pathname}?share=${b64}`;
          showShareModal(shareUrl);
        } catch (e) {
          // fallback to previous behavior
          shareBoard();
        }
      });
    }

    // Modal helpers
    const shareModal = document.getElementById('shareModal');
    const modalBackdrop = document.getElementById('modalBackdrop');
    const modalDialog = document.getElementById('modalDialog');
    const qrImage = document.getElementById('qrImage');
    const shareUrlText = document.getElementById('shareUrlText');
    const copyLinkBtn = document.getElementById('copyLinkBtn');
    const closeBtn = document.getElementById('closeBtn');
    const modalClose = document.getElementById('modalClose');

    function showShareModal(url) {
      // Use a public QR image generator (no external JS). If you need offline, we can embed a small QR encoder.
      const size = 240; // pixels
      console.log(url)
      const encoded = url// encodeURIComponent(url);
      // Using goqr.me / api.qrserver.com for fast generation
      const qrSrc = `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encoded}`;
      qrImage.src = qrSrc;
      shareUrlText.textContent = url;
      shareUrlText.href = url;
      // show modal
      shareModal.style.display = 'block';
      shareModal.setAttribute('aria-hidden', 'false');
      // focus
      copyLinkBtn.focus();
      // prevent background scroll
      document.body.style.overflow = 'hidden';
    }

    function closeShareModal() {
      shareModal.style.display = 'none';
      shareModal.setAttribute('aria-hidden', 'true');
      document.body.style.overflow = '';
    }

    // close handlers
    modalBackdrop.addEventListener('click', (ev) => {
      if (ev.target === modalBackdrop) closeShareModal();
    });
    closeBtn.addEventListener('click', closeShareModal);
    modalClose.addEventListener('click', closeShareModal);
    document.addEventListener('keydown', (ev) => {
      if (ev.key === 'Escape' && shareModal.style.display === 'block') closeShareModal();
    });

    copyLinkBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(shareUrlText.textContent);
        copyLinkBtn.textContent = 'Copiado!';
        setTimeout(() => (copyLinkBtn.textContent = 'Copiar link'), 1400);
      } catch (e) {
        prompt('Copie o link abaixo', shareUrlText.textContent);
      }
    });

    backBtn.addEventListener('click', () => {
      window.location.href = '/';
    });

    // Primeiro render
    makeGrid();

    // Re-render on orientation/resize to adjust cell sizes
    let rTimer = null;
    window.addEventListener('resize', () => {
      clearTimeout(rTimer);
      rTimer = setTimeout(() => makeGrid(), 120);
    });
  </script>
</body>

</html>